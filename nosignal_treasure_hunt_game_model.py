# -*- coding: utf-8 -*-
"""2023-Berrout-Laura-Assignment-3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1wSFDh7QAw2x7HGrn6MrK-H39jRxKzMIB

**Assignment #3**

No-Signal Treasure Hunt Game Model

Laura A. Berrout Ramos

**Part 1**
"""

pip install pyibl

import pyibl
from pyibl import Agent
import random
import matplotlib.pyplot as plt
import numpy as np

# Reward
# Chose a unprotected box, treasure =  100 pts
# Protected box = -50 pts
# Goal is to earn as many points as possible

# Player chooses a box
# Might received an alert that its protected, which could be a lie.
# Player can choose to access the box
# - If choose not to: 0 pts
# - If choose to access and NOT protected: 100 pts
# - If choose to accees and protected: -50


access = 0                         # Chooses to access the box
protected_box = [0,0]

def Reward(box_protected, points, access):
  if box_protected == 1 and access == 1:
    points -= 50
  elif box_protected == 0 and access == 1:
    points += 100
  return points


def Defender():
  # Alerts if the box is protected or not, and might be a lie.
  protected_box = [0,0]     #[Tells if protected or not, Truly protected]
  if random.random() <= 0.5:
    print("The box is protected!")
    protected_box[0] = 1
  else:
    print("The box is NOT protected.")
    protected_box[0] = 0

  # The truly protection of the box
  if random.random() <= 0.5:
    protected_box[1] = 1
  return protected_box

a = Agent(name="My Agent")
a.default_utility = 500

treasure_box = random.randint(1,2)    # The same as the player's choice, random
                                      # position between two numbers

options = ['Y','N']     # Y - Access box, N- Withdraw. Since we want to measure
                        # the respond of the player if the choose to access
                        # the chosen box or not.
rounds = 10
points = 0
access_times = 0
withdraw_times = 0
times_accessing_protected = 0
times_accessing_noprotected = 0
times_withdraw_protected = 0
times_withdraw_noprotected = 0

for r in range(rounds):
  a.reset()
  print("Round", r+1)
  choice_player = random.randint(1,2)
  box_protected = Defender()
  user_input = a.choose(options)
  print("Input:", str(user_input))
  if user_input == 'Y':
    access_times += 1
    access = 1
  else:
    withdraw_times += 1
    access = 0
  points = Reward(box_protected[1], points, access)
  a.respond(points)
  if access == 1:
    if box_protected[1] == 0:
      print("You found the treasure!")
    elif box_protected[1] == 1:
      print("Sorry, this box was protected")

    # Accessed to the box even when told it was protected
    if box_protected[0] == 1:
      times_accessing_protected += 1
    # Accessed to the box even when told it was NOT protected
    if box_protected[0] == 0:
      times_accessing_noprotected += 1

  if access == 0:
    if box_protected[0] == 1:
      times_withdraw_protected +=1
    elif box_protected[0] == 0:
      times_withdraw_noprotected +=1

  print("You have:",points,"points\n")


# Count access when defenser said was protected
# Count withdraw when defender said was protected
print("**** END OF GAME ****")
print("Your total points:", points)
print("Times accessing the box:", access_times)
print("Times withdrawing:", withdraw_times)
print("Times accessed the box and told was protected:", times_accessing_protected)
print("Times accessed the box and told was not protected:", times_accessing_noprotected)
print("Times withdrawing when told was protected:", times_withdraw_protected)
print("Times withdrawing when told was NOT protected:", times_withdraw_noprotected)

# Creating the bar plots
# Attacks on covered box, uncovered box and withdraw action
fig, ax = plt.subplots(figsize=(10,5))
data = [times_accessing_protected, times_accessing_noprotected, withdraw_times]
values = ['Attacks on Protected Box', 'Attacks on Non-Protected Box', 'Withdraw']
plt.bar(values, data, width = 0.4)
plt.title("Access and Withdraw actions")
for index in range(len(data)):
  ax.text(index, data[index], data[index])
plt.show()

"""**Part 2**"""

# New Defender's algorithm
# - If the selected box is covered, always send a warning signal i.e., signal
#   indicated the box is protected.
# - If the selected box is not covered, randomize between truthful signal or
#   deceptive signal i.e., send a warning signal 50% (deceptive) and send no
#   warning other 50% times (truthful).

def Defender2():
  # Alerts if the box is protected or not, and might be a lie.
  protected_box = [0,0]     #[Tells if protected or not, Truly protected]

  # Decide first if the box is (truly) protected or not
  if random.random() <= 0.5:
    protected_box[1] = 1   # Box is protected
    protected_box[0] = 1   # Tells the box is protected
    print("The box is protected!")

  # If the box is NOT proteceted, 50% tells protected or no tell
  else:
    if random.random() <= 0.5:
      print("The box is protected!")

  return protected_box

# Start over with the new Defender algorithm

points2 = 0
access_times2 = 0
withdraw_times2 = 0
times_accessing_protected2 = 0
times_accessing_noprotected2 = 0
times_withdraw_protected2 = 0
times_withdraw_noprotected2 = 0

for r in range(rounds):
  a.reset()
  print("Round", r+1)
  choice_player = random.randint(1,2)
  box_protected2 = Defender2()
  user_input = a.choose(options)
  print("Input:", str(user_input))
  if user_input == 'Y':
    access_times2 += 1
    access = 1
  else:
    withdraw_times2 += 1
    access = 0
  points2 = Reward(box_protected2[1], points2, access)
  a.respond(points2)
  if access == 1:
    if box_protected2[1] == 0:
      print("You found the treasure!")
    elif box_protected2[1] == 1:
      print("Sorry, this box was protected")

    # Accessed to the box even when told it was protected
    if box_protected2[0] == 1:
      times_accessing_protected2 += 1
    # Accessed to the box even when told it was NOT protected
    if box_protected2[0] == 0:
      times_accessing_noprotected2 += 1

  if access == 0:
    if box_protected2[0] == 1:
      times_withdraw_protected2 +=1
    elif box_protected2[0] == 0:
      times_withdraw_noprotected2 +=1

  print("You have:",points2,"points\n")


# Count access when defenser said was protected
# Count withdraw when defender said was protected
print("**** END OF GAME ****")
print("Your total points:", points2)
print("Times accessing the box:", access_times2)
print("Times withdrawing:", withdraw_times2)
print("Times accessed the box and told was protected:", times_accessing_protected2)
print("Times accessed the box and told was not protected:", times_accessing_noprotected2)
print("Times withdrawing when told was protected:", times_withdraw_protected2)
print("Times withdrawing when told was NOT protected:", times_withdraw_noprotected2)

# Creating the bar plots with new Defender algorithm
# Attacks on covered box, uncovered box and withdraw action
fig, ax = plt.subplots(figsize=(10,5))
data = [times_accessing_protected2, times_accessing_noprotected2, withdraw_times2]
values = ['Attacks on Protected Box', 'Attacks on Non-Protected Box', 'Withdraw']
plt.bar(values, data, width = 0.4)
plt.title("Access and Withdraw actions")
for index in range(len(data)):
  ax.text(index, data[index], data[index])
plt.show()